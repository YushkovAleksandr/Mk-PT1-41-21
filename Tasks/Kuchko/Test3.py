# 1. Прочитать содержимое файла text.txt
# 2. Дать пользователю ввести с клавиатуры параметр "максимальное количество символов в строке", 
# который должен быть больше 35
# 3. Отформатировать текст с учётом максимального количества символов, при этом если слово целиком не умещается в строке,
#  оно должно быть перенесено на следующую, а отступы между словами равномерно увеличены (по аналогии с 
# функцией "Выровнять по ширине" текстовых редакторов)
# 4. Записать получившийся текст в новый файл и оповестить об этом пользователя.
# (модуль textwrap использовать нельзя)

import re

a = int(input('максимальное количество символов в строке (больше 35): '))
if a < 35:
    a = int(input('Введите новое число больше 35 :'))

# Читаем файл text.txt с данными, форматируем его в зависимости от длины сроки введенной пользователем и перезаписываем
# в новый файл text1.txt (Вам для наглядности) 

with open('text.txt', 'r') as f:
    b = f.readlines()
    
    with open('text1.txt', 'w') as f:
        for s in b:
            if s == "": 
                print()
            w = 0
            l = []
            for d in s.split():
                if w + len(d) + 1 <= a:
                    l.append(d)
                    w += len(d) + 1
                else:
                    print(" ".join(l), file = f)
                    l = [d]
                    w = len(d)
            if (len(l)): 
                print(" ".join(l), file = f)

# Считываем файл text1.txt, дополняем пробелами между словами и записываем в файл text2.txt. 
# Код требует доработки, так как не все строки дополняет при различных длинах строки. Идея пройтись if-ами 
# различные варианты, но из-за времени не успеваю. 
# P.S. такой вариант наверное не очень. Сначала пробовал проходить каждую строку через список и join 
# (где пробелы добавлять ' ' через цикл пока строка не станет полной), но что-то код выводил не то, что нужно :) 
# поэтому решил поменять подход на следующий. Вроде итоговый результат выглядит более менее 
# (если бы я был пользователем, то немного поворчав согласился бы) (но есть нюансы (далее)). 

with open('text1.txt', 'r') as f:
    q = f.readlines()
    
    with open('text2.txt', 'w') as f:
        for line in q:
            space = a - len(line)
            words = len(line.split())
            if len(line) == a:
                print(line, file=f)   
            elif len(line) < a:
                if line[-1] == '/n':
                    print(line, file=f)
                elif words == 2:
                    print(re.sub(' ', ' ' * space, line, count=space), file=f)
                elif words == 3: # в принципе этот блок не нужен, но когда он есть, то для небольшой длины строки делает вывод красивее 
                    print(re.sub(' ', ' ' * (space//2), line, count=space), file=f)
                else:
                    print(re.sub(' ', '  ', line, count=space), file=f)
 
 # почему-то код добавляет после каждой строки в text2.txt дополнительные пустые строки без символов. 
 # Я так и не понял почему поэтому отформатировал text2.txt и перезаписал итоговый текст в файл text3.txt. 
 # В коде оставил вывод файла text2.txt чтобы Вы глянули может подскажете почему он дополняет пустыми строками?

fn = open('text2.txt', 'r') # тут решил без with open() чтобы потренироваться и так и так :) 
fn1 = open('text3.txt', 'w')

cont = fn.readlines()
for i in range(0, len(cont)):
    if i % 2 == 0:
        fn1.write(cont[i])
    else:
        pass

fn.close()
fn1.close()

print('Ваш текст находится в файле text3.txt')

